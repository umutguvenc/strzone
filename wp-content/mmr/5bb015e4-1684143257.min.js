const{Scene,PerspectiveCamera,WebGLRenderer,WebGL1Renderer,Clock,WebGLRenderTarget,OrthographicCamera,Color,RawShaderMaterial,ShaderMaterial,Vector2,Vector3,Mesh,Object3D,PlaneBufferGeometry,Raycaster,RepeatWrapping,DoubleSide,TextureLoader,MeshStandardMaterial,AmbientLight,DirectionalLight,BufferGeometry,BufferAttribute,Float32BufferAttribute,UnsignedByteType,LinearFilter,RGBAFormat,FloatType,ClampToEdgeWrapping,MeshBasicMaterial,NearestFilter,UniformsUtils}=THREE
class Stage3d{constructor({alpha=!1,antialias=!1,autoClear=!0,camera='perspective',clearColor=0xff0000,opacity=1,preserveDrawingBuffer=!1,webgl1=!1,className='canvas',onResize=!0,width=!1,height=!1,}={}){this.className=className
this.scenes=[];this.renderers=[];this.renderTargets=[];this.cameras=[];this.layers={DEFAULT:0,STENCIL:1,}
this.width=width?width:window.innerWidth
this.height=height?height:window.innerHeight
this.activeResize=onResize
this.autoClear=autoClear
this.scene=new Scene();this.scenes.push({id:'mainScene',scene:this.scene});this.camera=camera==='perspective'?this.addPerspectiveCamera({id:'mainCamera',}):this.addOrthographicCamera({id:'mainCamera'})
this.camera.position.z=10;this.renderer=webgl1?new WebGL1Renderer({alpha,antialias,preserveDrawingBuffer,}):new WebGLRenderer({alpha,antialias,preserveDrawingBuffer,})
this.canvas=this.renderer.domElement
this.renderer.domElement.classList.add(this.className)
this.renderer.autoClear=autoClear
this.renderer.setSize(this.width,this.height)
this.renderer.setClearColor(clearColor,opacity)
this.renderers.push(this.renderer)
this.time=0;this.delta=0;this.clock=new Clock()
this.composer=null;this.setup()
this.addEvents(onResize)}
setup(){this.isWebGL2Available=!1
try{const canvas=document.createElement('canvas');this.isWebGL2Available=!!(window.WebGL2RenderingContext&&canvas.getContext('webgl2'))}catch(e){this.isWebGL2Available=!1}}
addEvents(onResize){if(onResize){window.addEventListener('resize',this.onResize.bind(this))
this.onResize()}}
getDOMElement(){return this.renderer.domElement}
add(obj,scene=null){if(!scene){this.scene.add(obj)}else{scene.add(obj)}}
remove(obj,scene=null){if(!scene){this.scene.remove(obj)}else{scene.remove(obj)}}
addScene({id='',scene=new Scene()}={}){this.scenes.push({id,scene});return scene}
getScene(id){for(let i=0;i<this.scenes.length;i++){const scene=this.scenes[i];if(scene.id===id){return scene.scene}}
return console.error(`no scene found with the id : ${id}`)}
addRenderer({id='',renderer=new WebGLRenderer()}={}){this.renderers.push({id,renderer});return renderer}
getRenderer(id){for(let i=0;i<this.renderers.length;i++){const renderer=this.renderers[i];if(renderer.id===id){return renderer.renderer}}
return console.error(`no renderer found with the id : ${id}`)}
addRenderTarget({id='',renderTarget=new WebGLRenderTarget()}={}){this.renderTargets.push({id,renderTarget});return renderTarget}
getRenderTarget(id){for(let i=0;i<this.renderTargets.length;i++){const renderTarget=this.renderTargets[i];if(renderTarget.id===id){return renderTarget.renderTarget}}
return console.error(`no render target found with the id : ${id}`)}
addPerspectiveCamera({id='',fov=45,width=window.innerWidth,height=window.innerHeight,near=0.2,far=100,onResize=!0}={}){const camera=new PerspectiveCamera(fov,width/height,near,far)
this.cameras.push({id,camera,type:'perspective',onResize});return camera}
addOrthographicCamera({id='',width=window.innerWidth,height=window.innerHeight,near=0,far=100,position=new Vector3(0,0,1),onResize=!0}={}){const camera=new OrthographicCamera(width/-2,width/2,height/2,height/-2,near,far);camera.position.copy(position)
this.cameras.push({id,camera,type:'orthographic',onResize});return camera}
getCamera(id){for(let i=0;i<this.cameras.length;i++){const camera=this.cameras[i];if(camera.id===id){return camera.camera}}
return console.error(`no camera found with the id : ${id}`)}
setClearColor(color=0x000000,alpha=1){this.renderer.setClearColor(color,alpha)}
updateCamera({near=this.config.near.value,far=this.config.far.value,width=window.innerWidth,height=window.innerHeight,}={}){this.config.near.value=near
this.config.far.value=far
this.camera.far=far
this.camera.near=near
this.resize(width,height)}
updateBackground({scale=this.bgConfig.scale.value,color=this.bgConfig.color.value,color2=this.bgConfig.color2.value,}={}){this.bgConfig.scale.value=scale
this.bgConfig.color.value=color
this.bgConfig.color2.value=color2
this.backgroundMesh.scale.set(scale,scale,1)}
onResize(){const vw=window.innerWidth
const vh=window.innerHeight
if(this.activeResize){this.width=vw
this.height=vh
this.resize(this.width,this.height)}}
resize(width,height){for(let i=0;i<this.cameras.length;i++){const camera=this.cameras[i]
if(camera.onResize){if(camera.type==='perspective'){camera.camera.aspect=width/height
camera.camera.updateProjectionMatrix()}else{camera.camera.left=width/-2
camera.camera.right=width/2
camera.camera.top=height/2
camera.camera.bottom=height/-2
camera.camera.updateProjectionMatrix()}}}
this.renderer.setSize(width,height)}
render(){}}
window.S3D=new Stage3d({alpha:!0,antialias:!0,autoClear:!0,camera:'perspective',className:'canvas__ribbon',clearColor:0x000000,opacity:0,preserveDrawingBuffer:!0,webgl1:!1,onResize:!0,width:window.innerWidth,height:window.innerHeight});const CopyShader={uniforms:{'tDiffuse':{value:null},'opacity':{value:1.0}},vertexShader:`
		varying vec2 vUv;
		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,fragmentShader:`
		uniform float opacity;
		uniform sampler2D tDiffuse;
		varying vec2 vUv;
		void main() {
			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;
		}`}
class Pass{constructor(){this.enabled=!0
this.needsSwap=!0
this.clear=!1
this.renderToScreen=!1}
setSize(){}
render(){}
dispose(){}}
const _camera=new OrthographicCamera(-1,1,1,-1,0,1)
const _geometry=new BufferGeometry()
_geometry.setAttribute('position',new Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3))
_geometry.setAttribute('uv',new Float32BufferAttribute([0,2,0,0,2,0],2))
class FullScreenQuad{constructor(material){this._mesh=new Mesh(_geometry,material)}
dispose(){this._mesh.geometry.dispose()}
render(renderer){renderer.render(this._mesh,_camera)}
get material(){return this._mesh.material}
set material(value){this._mesh.material=value}}
class ShaderPass extends Pass{constructor(shader,textureID){super()
this.textureID=(textureID!==undefined)?textureID:'tDiffuse';if(shader instanceof ShaderMaterial){this.uniforms=shader.uniforms
this.material=shader}else if(shader){this.uniforms=UniformsUtils.clone(shader.uniforms)
this.material=new ShaderMaterial({defines:Object.assign({},shader.defines),uniforms:this.uniforms,vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader})}
this.fsQuad=new FullScreenQuad(this.material)}
render(renderer,writeBuffer,readBuffer){if(this.uniforms[this.textureID]){this.uniforms[this.textureID].value=readBuffer.texture}
this.fsQuad.material=this.material;if(this.renderToScreen){renderer.setRenderTarget(null);this.fsQuad.render(renderer)}else{renderer.setRenderTarget(writeBuffer)
if(this.clear)renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil)
this.fsQuad.render(renderer)}}
dispose(){this.material.dispose()
this.fsQuad.dispose()}}
class MaskPass extends Pass{constructor(scene,camera){super()
this.scene=scene
this.camera=camera
this.clear=!0
this.needsSwap=!1
this.inverse=!1}
render(renderer,writeBuffer,readBuffer){const context=renderer.getContext()
const state=renderer.state
state.buffers.color.setMask(!1);state.buffers.depth.setMask(!1);state.buffers.color.setLocked(!0);state.buffers.depth.setLocked(!0);let writeValue,clearValue
if(this.inverse){writeValue=0;clearValue=1}else{writeValue=1;clearValue=0}
state.buffers.stencil.setTest(!0);state.buffers.stencil.setOp(context.REPLACE,context.REPLACE,context.REPLACE);state.buffers.stencil.setFunc(context.ALWAYS,writeValue,0xffffffff);state.buffers.stencil.setClear(clearValue);state.buffers.stencil.setLocked(!0);renderer.setRenderTarget(readBuffer);if(this.clear)renderer.clear();renderer.render(this.scene,this.camera);renderer.setRenderTarget(writeBuffer);if(this.clear)renderer.clear();renderer.render(this.scene,this.camera);state.buffers.color.setLocked(!1);state.buffers.depth.setLocked(!1);state.buffers.stencil.setLocked(!1);state.buffers.stencil.setFunc(context.EQUAL,1,0xffffffff);state.buffers.stencil.setOp(context.KEEP,context.KEEP,context.KEEP);state.buffers.stencil.setLocked(!0)}}
class ClearMaskPass extends Pass{constructor(){super()
this.needsSwap=!1}
render(renderer){renderer.state.buffers.stencil.setLocked(!1);renderer.state.buffers.stencil.setTest(!1)}}
class EffectComposer{constructor(renderer,renderTarget){this.renderer=renderer
if(renderTarget===undefined){const size=renderer.getSize(new Vector2())
this._pixelRatio=renderer.getPixelRatio()
this._width=size.width
this._height=size.height
renderTarget=new WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio)
renderTarget.texture.name='EffectComposer.rt1'}else{this._pixelRatio=1
this._width=renderTarget.width
this._height=renderTarget.height}
this.renderTarget1=renderTarget
this.renderTarget2=renderTarget.clone()
this.renderTarget2.texture.name='EffectComposer.rt2'
this.writeBuffer=this.renderTarget1
this.readBuffer=this.renderTarget2
this.renderToScreen=!0
this.passes=[]
this.copyPass=new ShaderPass(CopyShader)
this.clock=new Clock()}
swapBuffers(){const tmp=this.readBuffer
this.readBuffer=this.writeBuffer
this.writeBuffer=tmp}
addPass(pass){this.passes.push(pass)
pass.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}
insertPass(pass,index){this.passes.splice(index,0,pass)
pass.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}
removePass(pass){const index=this.passes.indexOf(pass)
if(index!==-1){this.passes.splice(index,1)}}
isLastEnabledPass(passIndex){for(let i=passIndex+1;i<this.passes.length;i ++){if(this.passes[i].enabled){return!1}}
return!0}
render(deltaTime){if(deltaTime===undefined){deltaTime=this.clock.getDelta()}
const currentRenderTarget=this.renderer.getRenderTarget();let maskActive=!1
for(let i=0,il=this.passes.length;i<il;i ++){const pass=this.passes[i]
if(pass.enabled===!1)continue
pass.renderToScreen=(this.renderToScreen&&this.isLastEnabledPass(i))
pass.render(this.renderer,this.writeBuffer,this.readBuffer,deltaTime,maskActive)
if(pass.needsSwap){if(maskActive){const context=this.renderer.getContext();const stencil=this.renderer.state.buffers.stencil;stencil.setFunc(context.NOTEQUAL,1,0xffffffff)
this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,deltaTime);stencil.setFunc(context.EQUAL,1,0xffffffff)}
this.swapBuffers()}
if(MaskPass!==undefined){if(pass instanceof MaskPass){maskActive=!0}else if(pass instanceof ClearMaskPass){maskActive=!1}}}
this.renderer.setRenderTarget(currentRenderTarget)}
reset(renderTarget){if(renderTarget===undefined){const size=this.renderer.getSize(new Vector2())
this._pixelRatio=this.renderer.getPixelRatio()
this._width=size.width
this._height=size.height
renderTarget=this.renderTarget1.clone()
renderTarget.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}
this.renderTarget1.dispose()
this.renderTarget2.dispose()
this.renderTarget1=renderTarget
this.renderTarget2=renderTarget.clone()
this.writeBuffer=this.renderTarget1
this.readBuffer=this.renderTarget2}
setSize(width,height){this._width=width;this._height=height;const effectiveWidth=this._width*this._pixelRatio
const effectiveHeight=this._height*this._pixelRatio
this.renderTarget1.setSize(effectiveWidth,effectiveHeight)
this.renderTarget2.setSize(effectiveWidth,effectiveHeight)
for(let i=0;i<this.passes.length;i ++){this.passes[i].setSize(effectiveWidth,effectiveHeight)}}
setPixelRatio(pixelRatio){this._pixelRatio=pixelRatio
this.setSize(this._width,this._height)}
dispose(){this.renderTarget1.dispose()
this.renderTarget2.dispose()
this.copyPass.dispose()}}
class BigTriangle extends Object3D{constructor({positions=new Float32Array([-0.5,-0.5,1.5,-0.5,-0.5,1.5]),uvs=new Float32Array([0,0,2,0,0,2]),stageID=`big-triangle-${Math.random()}`,material=new RawShaderMaterial({uniforms:{t_diffuse:null,},vertexShader:`precision highp float;
      uniform mat4 projectionMatrix;
      uniform mat4 modelMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 modelViewMatrix;
      attribute lowp vec2 position;
      attribute lowp vec2 uv;
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 0., 1.);
      }`,fragmentShader:`precision highp float;
      uniform sampler2D t_diffuse;
      varying vec2 vUv;
      void main() {
        vec4 texture = texture2D(t_diffuse, vUv);
        vec3 color = texture.rgb;
        float alpha = texture.a;
        gl_FragColor = vec4(color, alpha);
      }`,}),texture=null,scene=!1,camera=!1,}={}){super()
this._geometry=new BufferGeometry()
this._geometry.setAttribute('position',new BufferAttribute(positions,2))
this._geometry.setAttribute('uv',new BufferAttribute(uvs,2))
if(texture){material.uniforms.t_diffuse={value:texture}
material.uniforms.t_diffuse.value.needsUpdate=!0}
this._material=material
this._mesh=new Mesh(this._geometry,this._material)
this._mesh.frustumCulled=!1
this.add(this._mesh)
if(scene){this._camera=S3D.addOrthographicCamera({id:stageID,width:1,height:1,near:0,far:1,onResize:!1})
this._scene=S3D.addScene({id:stageID})
this._scene.add(this)}else if(camera){this._camera=S3D.addOrthographicCamera({id:stageID,width:1,height:1,near:0,far:1,onResize:!1})}}
dispose(){this._geometry.dispose()
this._material.dispose()}
get geometry(){return this._geometry}
get material(){return this._material}
set material(material){this._material=material
this._mesh.material=material}
get scene(){return this._scene}
get mesh(){return this._mesh}
get camera(){return this._camera}}
class RenderPass extends Pass{constructor(scene,camera,overrideMaterial,clearColor,clearAlpha){super();this.scene=scene;this.camera=camera;this.overrideMaterial=overrideMaterial;this.clearColor=clearColor;this.clearAlpha=(clearAlpha!==undefined)?clearAlpha:0;this.clear=!0;this.clearDepth=!1;this.needsSwap=!1;this._oldClearColor=new Color()}
render(renderer,writeBuffer,readBuffer){const oldAutoClear=renderer.autoClear;renderer.autoClear=!1;let oldClearAlpha,oldOverrideMaterial;if(this.overrideMaterial!==undefined){oldOverrideMaterial=this.scene.overrideMaterial;this.scene.overrideMaterial=this.overrideMaterial}
if(this.clearColor){renderer.getClearColor(this._oldClearColor);oldClearAlpha=renderer.getClearAlpha();renderer.setClearColor(this.clearColor,this.clearAlpha)}
if(this.clearDepth){renderer.clearDepth()}
renderer.setRenderTarget(this.renderToScreen?null:readBuffer);if(this.clear)renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);renderer.render(this.scene,this.camera);if(this.clearColor){renderer.setClearColor(this._oldClearColor,oldClearAlpha)}
if(this.overrideMaterial!==undefined){this.scene.overrideMaterial=oldOverrideMaterial}
renderer.autoClear=oldAutoClear;writeBuffer.samples=0
readBuffer.samples=0}}
class FBO2{constructor({width=256,height=256,format=RGBAFormat,type=FloatType,minFilter=NearestFilter,magFilter=NearestFilter,depthBuffer=!1,stageID=`fbo-${Math.random()}`,material,debug=!1}={}){this.simulation=material
const options={wrapS:ClampToEdgeWrapping,wrapT:ClampToEdgeWrapping,minFilter,magFilter,format,type,stencilBuffer:!1,depthBuffer,generateMipmaps:!1,}
this._read=new WebGLRenderTarget(width,height,options)
this._write=new WebGLRenderTarget(width,height,options)
if(debug){this.debug()}}
swap(){let temp=this._read
this._read=this._write
this._write=temp}
debug(){this.debug1=new Mesh(new PlaneBufferGeometry(0.4,0.4),new MeshBasicMaterial({map:this._read.texture}))
this.debug2=new Mesh(new PlaneBufferGeometry(0.4,0.4),new MeshBasicMaterial({map:this._write.texture}))
this.debug1.position.set(-0.25,0,0.5)
this.debug2.position.set(0.25,0,0.5)
S3D.add(this.debug1)
S3D.add(this.debug2)}
get read(){return this._read}
get write(){return this._write}
setSize(width,height){this._read.setSize(width,height)
this._write.setSize(width,height)}}
const kernelPresets=[new Float32Array([0.0,0.0]),new Float32Array([0.0,1.0,1.0]),new Float32Array([0.0,1.0,1.0,2.0]),new Float32Array([0.0,1.0,2.0,2.0,3.0]),new Float32Array([0.0,1.0,2.0,3.0,4.0,4.0,5.0]),new Float32Array([0.0,1.0,2.0,3.0,4.0,5.0,7.0,8.0,9.0,10.0])]
class ConvolutionMaterial extends RawShaderMaterial{constructor({texelSize=new Vector2(),scale=1,kernelSize=2,depthTest=!1,depthWrite=!1,}={}){super({depthTest,depthWrite,uniforms:{t_diffuse:{value:null},u_texelSize:{value:texelSize},u_halfTexelSize:{value:texelSize},u_kernel:{value:0},u_scale:{value:scale}},vertexShader:`precision highp float;
      uniform mat4 projectionMatrix;
      uniform mat4 modelMatrix;
      uniform mat4 viewMatrix;
      uniform mat4 modelViewMatrix;
      uniform vec2 u_texelSize;
      uniform vec2 u_halfTexelSize;
      uniform float u_kernel;
      uniform float u_scale;
      attribute lowp vec2 position;
      attribute lowp vec2 uv;

      varying vec2 vUv;
      varying vec2 vUv0;
      varying vec2 vUv1;
      varying vec2 vUv2;
      varying vec2 vUv3;
      
      void main() {
        vUv = uv;
        vec2 uv = position.xy * 0.5 + 0.5;
        vec2 dUv = (u_texelSize * vec2(u_kernel) + u_halfTexelSize) * u_scale;
        vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);
        vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);
        vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);
        vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }`,fragmentShader:`precision highp float;
      #include <common>
      #include <dithering_pars_fragment>
      #ifdef FRAMEBUFFER_PRECISION_HIGH
        uniform mediump sampler2D t_diffuse;
      #else
        uniform lowp sampler2D t_diffuse;
      #endif
      varying vec2 vUv;
      varying vec2 vUv0;
      varying vec2 vUv1;
      varying vec2 vUv2;
      varying vec2 vUv3;
      void main() {
        vec4 sum = texture2D(t_diffuse, vUv0);
        sum += texture2D(t_diffuse, vUv1);
        sum += texture2D(t_diffuse, vUv2);
        sum += texture2D(t_diffuse, vUv3);
        gl_FragColor = sum * 0.25;
        #include <dithering_fragment>
      }`,})
this.kernelSize=kernelSize}
getKernel(){return kernelPresets[this.kernelSize]}
setTexelSize(x,y){this.uniforms.u_texelSize.value.set(x,y);this.uniforms.u_halfTexelSize.value.set(x,y).multiplyScalar(0.5)}}
class BlurPass extends Pass{constructor({active=!0,resolution=1,scale=1,kernelSize=4,}={}){super()
this.config={active:{value:active},resolution:{value:resolution},scale:{value:scale},kernel:{value:kernelSize}}
this.fbo=new FBO2({depthBuffer:!1,type:UnsignedByteType,minFilter:LinearFilter,magFilter:LinearFilter,width:window.innerWidth*this.config.resolution.value,height:window.innerHeight*this.config.resolution.value})
this.convolutionMaterial=new ConvolutionMaterial({kernelSize,})
this.convolutionMaterial.uniforms.u_scale=this.config.scale
this.convolutionMesh=new BigTriangle({positions:new Float32Array([-1,-1,3,-1,-1,3]),material:this.convolutionMaterial,camera:!0})
S3D.post.composer.addPass(this)
this.enabled=this.config.active.value}
setSize(width,height){const w=width*this.config.resolution.value
const h=height*this.config.resolution.value
this.fbo.setSize(w,h)
this.convolutionMaterial.setTexelSize(1/w,1/h)}
render(renderer,writeBuffer,readBuffer,deltaTime,maskActive){const kernel=this.convolutionMaterial.getKernel()
let i;for(i=0;i<kernel.length-1;++i){this.convolutionMaterial.uniforms.u_kernel.value=this.convolutionMaterial.getKernel()[i]
this.convolutionMaterial.uniforms.t_diffuse.value=i===0?readBuffer.texture:this.fbo.read.texture
renderer.setRenderTarget(this.fbo.write)
renderer.render(this.convolutionMesh.mesh,this.convolutionMesh.camera)
this.fbo.swap()}
this.convolutionMaterial.uniforms.u_kernel.value=this.convolutionMaterial.getKernel()[i]
this.convolutionMaterial.uniforms.t_diffuse.value=this.fbo.read.texture
renderer.setRenderTarget(this.renderToScreen?null:readBuffer)
renderer.render(this.convolutionMesh.mesh,this.convolutionMesh.camera)}}
class Postprocessing{constructor(){S3D.post=this
this.config={active:{value:!1},}
this.composer=new EffectComposer(S3D.renderer)
this.quad=new BigTriangle({positions:new Float32Array([-1,-1,3,-1,-1,3]),camera:!0})
this.renderPass=new RenderPass(S3D.scene,S3D.camera)
this.composer.addPass(this.renderPass)
this.blurPass=new BlurPass()
this.addEvents()}
activate(){this.config.active.value=!0}
deactivate(){this.config.active.value=!1}
addEvents(){window.addEventListener('resize',this.onResize)}
onResize(){this.resize()}
resize(w=window.innerWidth,h=window.innerHeight){this.composer.setSize(w,h)}
preRender(){}
render({renderTarget=null,scene=S3D.scene,camera=S3D.camera}={}){if(this.config.active.value){this.preRender()
this.composer.render()}else{S3D.renderer.setRenderTarget(renderTarget)
S3D.renderer.render(scene,camera)}}};const beginVs=`vec3 transformed = vec3( position );
`
const mapFs=`vec2 uv = vec2(vUv.x + u_time * 0.09, vUv.y);
vec4 sampledDiffuseColor = texture2D( map, uv);
diffuseColor *= sampledDiffuseColor;
`
class Stick{constructor({p1,p2,stiffness=2,color='#00ff00',length=!1,}={}){this.startPoint=p1
this.endPoint=p2
this.stiffness=stiffness
this.color=color
this.started=!1
if(!length){this.length=this.startPoint.pos.distanceTo(this.endPoint.pos)}else{this.length=length}
this.addEvents()}
addEvents(){window.addEventListener('resize',this.onResize.bind(this))
this.resize()}
onResize(){this.resize()}
resize(){this.length=this.startPoint.pos.distanceTo(this.endPoint.pos)}
preRender({ctx}={}){this.updatePhysics()}
updatePhysics(){let dx=this.endPoint.pos.x-this.startPoint.pos.x
let dy=this.endPoint.pos.y-this.startPoint.pos.y
let dz=this.endPoint.pos.z-this.startPoint.pos.z
let dist=Math.sqrt(dx*dx+dy*dy+dz*dz)
let diff=(this.length-dist)/dist*this.stiffness
let offsetx=dx*diff*0.5
let offsety=dy*diff*0.5
let offsetz=dz*diff*0.5
let m1=this.startPoint.mass+this.endPoint.mass
let m2=this.startPoint.mass/m1
m1=this.endPoint.mass/m1
if(!this.startPoint.pinned){this.startPoint.pos.x-=offsetx*m1
this.startPoint.pos.y-=offsety*m1
this.startPoint.pos.z-=offsetz*m1}
if(!this.endPoint.pinned){this.endPoint.pos.x+=offsetx*m2
this.endPoint.pos.y+=offsety*m2
this.endPoint.pos.z+=offsetz*m2}}}
class Dot{constructor({x=1,y=0,z=0,vx=0,vy=0,vz=0,friction=new Vector3(0.97,0.97,0.97),groundFriction=new Vector3(0.7,0.7,0.7),gravity=new Vector3(0,-0.001,0),radius=5,color='#ff0000',mass=1,index=0,array=[],pinned=!1}={}){this.originalPos=new Vector3(x,y,z)
this.pos=new Vector3(x,y,z)
this.oldPos=new Vector3(x+vx,y+vy,z+vz)
this.offset=new Vector3(0,0,0)
this.intersectionPoint=new Vector3(0,0,0)
this.magnitude=new Vector3()
this.friction=friction
this.groundFriction=groundFriction
this.gravity=gravity
this.radius=radius
this.color=color
this.mass=mass
this.index=index
this.array=array
this.wind=new Vector3()
this.pinned=pinned
this.vel=new Vector3()
this.addEvents()}
addEvents(){window.addEventListener('resize',this.onResize.bind(this))
this.resize()}
mousemove(point){const x=map(point.x,-1,1,-1.5,3)
const y=map(point.y,-1,1,0.75,-2)
const z=0
this.intersectionPoint.set(x,y,z)
this.intersectionPoint.multiplyScalar(0.01)}
onResize(){this.resize()}
resize(){const pSize=getPerspectiveSize(S3D.camera,S3D.camera.position.z)
const w=pSize.width*0.7
const h=pSize.height*0.07
const y=map(this.originalPos.x,-1,1,-2,0)
this.offset.set(0,y,0)
this.pos.set(this.originalPos.x*w,this.originalPos.y*h,0)
this.pos.add(this.offset)
this.oldPos.copy(this.pos)
this.vel.set(0,0,0)
this.array[this.index+0]=this.pos.x
this.array[this.index+1]=this.pos.y
this.array[this.index+2]=this.pos.z}
updatePhysics(){const n=noise(this.pos.x*this.magnitude.x+S3D.time*this.magnitude.z,this.pos.y*this.magnitude.z+S3D.time*this.magnitude.z+this.magnitude.z)
this.wind.multiplyScalar(n)
this.vel.set(this.pos.x-this.oldPos.x,this.pos.y-this.oldPos.y,this.pos.z-this.oldPos.z)
this.vel.multiply(this.friction)
const magnitudeSqrt=this.vel.x*this.vel.x+this.vel.y*this.vel.y+this.vel.z*this.vel.z
if(magnitudeSqrt>0.000001){const magnitude=Math.sqrt(magnitudeSqrt)
this.vel.x/=magnitude
this.vel.y/=magnitude
this.vel.z/=magnitude
this.vel.x*=magnitude*this.groundFriction.x
this.vel.y*=magnitude*this.groundFriction.y
this.vel.z*=magnitude*this.groundFriction.z}
this.oldPos.copy(this.pos)
this.pos.add(this.vel)
this.pos.add(this.gravity)
this.pos.add(this.intersectionPoint)
this.pos.add(this.wind)
this.array[this.index+0]=this.pos.x
this.array[this.index+1]=this.pos.y
this.array[this.index+2]=this.pos.z}
constrain(){if(this.pos.x>window.innerWidth-this.radius){this.pos.x=window.innerWidth-this.radius}
if(this.pos.x<this.radius){this.pos.x=this.radius}
if(this.pos.y>window.innerHeight-this.radius){this.pos.y=window.innerHeight-this.radius}
if(this.pos.y<this.radius){this.pos.y=this.radius}}}
class ExtendedStandardMaterial extends MeshStandardMaterial{constructor(options={}){super(options)
this.uniforms=options.uniforms?options.uniforms:{}
this.onBeforeCompile=options.onBeforeCompile?options.onBeforeCompile:function(){}}
getUniformType(value){if(value.isVector2){return'vec2'}else if(value.isVector3||value.isColor){return'vec3'}else if(value.isVector4){return'vec4'}else if(value.isMatrix4){return'mat4'}else if(typeof value==='boolean'){return'bool'}else if(typeof value==='number'){return'float'}else{return'sampler2D'}}}
class Verlet extends Object3D{constructor(){super()
this.iterations=15
this.vertices=15
this.w=2
this.h=2
this.offset=0
this.toLoad=0
this.dots=[]
this.sticks=[]
this.array=[]
this.textures=[]
this.m={x:0,y:0}
this.mPr={x:0,y:0}
this.delta={x:0,y:0}
this.raycaster=new Raycaster()
this.pointer=new Vector2()
this.prPointer=new Vector2()
this.elPointer=new Vector2()
this.intersection=!1
this.objectVisible=!1
this.objectShowed=!1
this.clicked=!1
this.loaded=!1
this.config={position:{value:new Vector3(0,4,0),min:-10,max:10,step:0.01},rotation:{value:new Vector3(0,0,0),min:0,max:Math.PI,step:0.01},magnitude:{value:new Vector3(0.051,0.236,0.198),min:0,max:3,step:0.001},groundFriction:{value:new Vector3(0.1,0.1,0.1),min:0,max:1,step:0.01},friction:{value:new Vector3(0.99,0.99,0.99),min:0,max:1,step:0.01},mass:{value:1,min:0.1,max:10,step:0.01},wind:{value:new Vector3(0.002,0.075,0.006),min:0,max:0.2,step:0.001},speed:{value:new Vector3(1.5,3.2,3.5),min:0,max:5,step:0.1},stiffness:{value:2.2,min:0,max:5,step:0.1},gravity:{value:new Vector3(0,-0.006,0),min:-0.03,max:0.03,step:0.001},}
this.ui={hero:document.body.querySelector('.banner-hero'),work:document.body.querySelector('.banner-hero__item.item-1.has-ribbon'),vibes:document.body.querySelector('.banner-hero__item.item-2.has-ribbon'),services:document.body.querySelector('.banner-hero__item.item-3.has-ribbon'),}
this.setupLights()
this.setupGeometry()
this.setupMaterial()
this.setupMesh()
this.addEvents()}
setupLights(){const ambientLight=new AmbientLight(0xffffff,1)
S3D.add(ambientLight)
const directionalLight=new DirectionalLight(0xaaaaaa,1)
directionalLight.position.set(0,0.54,0.24)
S3D.add(directionalLight)}
setupGeometry(){this.geometry=new PlaneBufferGeometry(this.w,this.h,this.vertices,this.vertices)
this.geometry.rotateZ(this.config.rotation.value.z)
this.nb=this.geometry.attributes.position.count
for(let i=0;i<this.geometry.attributes.position.count;i++){const x=this.geometry.attributes.position.array[i*3+0]
const y=this.geometry.attributes.position.array[i*3+1]
const z=this.geometry.attributes.position.array[i*3+2]
const pinned=i===0||i===this.vertices?!0:!1
this.dots.push(new Dot({x,y,z,index:i*3,array:this.geometry.attributes.position.array,pinned}))}
for(let i=0;i<this.vertices;i++){for(let j=0;j<this.vertices;j++){const index=i*(this.vertices+1)+j
this.sticks.push(new Stick({p1:this.dots[index],p2:this.dots[index+1]}))
this.sticks.push(new Stick({p1:this.dots[index+1],p2:this.dots[index+1+this.vertices+1]}))
this.sticks.push(new Stick({p1:this.dots[index+1+this.vertices+1],p2:this.dots[index+1+this.vertices]}))
this.sticks.push(new Stick({p1:this.dots[index+1+this.vertices],p2:this.dots[index]}))
this.sticks.push(new Stick({p1:this.dots[index+1+this.vertices],p2:this.dots[index+1]}))}}}
setupMaterial(){this.material=new ExtendedStandardMaterial({map:null,side:DoubleSide,roughness:1,metalness:0,transparent:!0,opacity:0,uniforms:{u_time:{value:0}},onBeforeCompile:function(shader){for(const uniform in this.uniforms){if(Object.hasOwnProperty.call(this.uniforms,uniform)){const element=this.uniforms[uniform]
const type=this.getUniformType(element.value)
shader.uniforms[uniform]=element
shader.vertexShader=`uniform ${type} ${uniform};\n`+shader.vertexShader
shader.fragmentShader=`uniform ${type} ${uniform};\n`+shader.fragmentShader}}
shader.vertexShader=shader.vertexShader.replace('#include <begin_vertex>',beginVs)
shader.fragmentShader=shader.fragmentShader.replace('#include <map_fragment>',mapFs)}})}
setupMesh(){this.mesh=new Mesh(this.geometry,this.material)
this.add(this.mesh)}
show({id,position}={}){if(!this.objectVisible){S3D.post.activate()
this.material.map=this.textures[id]
this.material.map.needsUpdate=!0
this.material.needsUpdate=!0
const duration=0.8
gsap.killTweensOf(S3D.post.blurPass.config.scale)
gsap.fromTo(S3D.post.blurPass.config.scale,{value:10},{value:0,duration,ease:'Power2.easeOut'})
gsap.killTweensOf(this.material)
gsap.to(this.material,{opacity:1,duration,ease:'Power2.easeOut',onComplete:()=>{S3D.post.deactivate()}})
const f=5
this.dots.forEach(dot=>{dot.oldPos.set(dot.pos.x+Math.random()*f-f*0.5,dot.pos.y+Math.random()*f-f*0.5,dot.pos.z+Math.random()*f-f*0.5)})
this.config.position.value.set(position[0],position[1],position[2])
this.objectVisible=!0
this.objectShowed=!0}}
hide(){if(this.objectVisible){S3D.post.activate()
gsap.killTweensOf(S3D.post.blurPass.config.scale)
gsap.to(S3D.post.blurPass.config.scale,{value:10,duration:0.4,ease:'Power2.easeOut'})
gsap.killTweensOf(this.material)
gsap.to(this.material,{opacity:0,duration:0.4,ease:'Power2.easeOut',onComplete:()=>{S3D.post.deactivate()
this.objectShowed=!1}})
this.objectVisible=!1}}
addEvents(){new TextureLoader().load('/wp-content/themes/wfn/assets/images/ribbon/work.jpg',(texture)=>{texture.wrapS=RepeatWrapping
texture.wrapT=RepeatWrapping
this.textures[0]=texture
this.material.map=texture
this.material.map.needsUpdate=!0
this.material.needsUpdate=!0
this.toLoad++
if(this.toLoad===3){this.loaded=!0
this.started=!0}})
new TextureLoader().load('/wp-content/themes/wfn/assets/images/ribbon/vibes.jpg',(texture)=>{texture.wrapS=RepeatWrapping
texture.wrapT=RepeatWrapping
this.textures[1]=texture
this.material.map=texture
this.material.map.needsUpdate=!0
this.material.needsUpdate=!0
this.toLoad++
if(this.toLoad===3){this.loaded=!0
this.started=!0}})
new TextureLoader().load('/wp-content/themes/wfn/assets/images/ribbon/services.jpg',(texture)=>{texture.wrapS=RepeatWrapping
texture.wrapT=RepeatWrapping
this.textures[2]=texture
this.material.map=texture
this.material.map.needsUpdate=!0
this.material.needsUpdate=!0
this.toLoad++
if(this.toLoad===3){this.loaded=!0
this.started=!0}})
this.ui.work.addEventListener('mouseenter',this.onWorkMouseenter.bind(this))
this.ui.vibes.addEventListener('mouseenter',this.onVibesMouseenter.bind(this))
this.ui.services.addEventListener('mouseenter',this.onServicesMouseenter.bind(this))
this.ui.hero.addEventListener('mousemove',this.onHeroMousemove.bind(this))
this.ui.work.addEventListener('mouseleave',this.onWorkMouseleave.bind(this))
this.ui.vibes.addEventListener('mouseleave',this.onVibesMouseleave.bind(this))
this.ui.services.addEventListener('mouseleave',this.onServicesMouseleave.bind(this))
window.addEventListener('resize',this.onResize.bind(this))
this.resize()}
onWorkMouseenter(){this.show({id:0,position:[0,3.9,0]})}
onVibesMouseenter(){this.show({id:1,position:[0,1.8,0]})}
onServicesMouseenter(){this.show({id:2,position:[0,-0.1,0]})}
onHeroMousemove(e){this.pointer.x=(e.clientX/window.innerWidth)*2-1
this.pointer.y=-(e.clientY/window.innerHeight)*2+1
this.elPointer.x=clamp((e.offsetX/e.target.offsetWidth)*2-1,-1,1)
this.elPointer.y=clamp((e.offsetY/e.target.offsetHeight)*2-1,-1,1)
this.dots.forEach(dot=>{dot.mousemove(this.elPointer)})
this.prPointer.x=this.pointer.x
this.prPointer.y=this.pointer.y}
onWorkMouseleave(){this.hide()}
onVibesMouseleave(){this.hide()}
onServicesMouseleave(){this.hide()}
onResize(){this.resize()}
resize(){}
preRender(){this.updatePhysics()
this.material.uniforms.u_time.value=S3D.time}
updateRaycast(){this.raycaster.setFromCamera(this.pointer,S3D.camera)
const intersects=this.raycaster.intersectObjects(this.children,!0)
if(intersects.length>0){this.intersection=intersects[0]}else{this.intersection=!1}}
updatePhysics(){this.position.copy(this.config.position.value)
for(let i=0;i<this.iterations;i++){this.sticks.forEach(stick=>{stick.stiffness=this.config.stiffness.value
stick.updatePhysics()})}
this.dots.forEach(dot=>{dot.magnitude.copy(this.config.magnitude.value)
dot.wind.set(Math.cos(S3D.time*this.config.speed.value.x+this.config.speed.value.x+this.offset)*this.config.wind.value.x,Math.sin(S3D.time*this.config.speed.value.y+this.config.speed.value.y+this.offset)*this.config.wind.value.y,Math.cos(S3D.time*this.config.speed.value.z+this.config.speed.value.z+this.offset)*this.config.wind.value.z)
dot.gravity.copy(this.config.gravity.value)
dot.groundFriction.copy(this.config.groundFriction.value)
dot.friction.copy(this.config.friction.value)
if(!dot.pinned)dot.updatePhysics({intersectPoint:this.intersectPoint})})
this.geometry.attributes.position.needsUpdate=!0
this.geometry.computeVertexNormals()}}
document.addEventListener('DOMContentLoaded',function(){const banner=document.body.querySelector('.banner-hero')
if(!banner)return
new Postprocessing()
banner.appendChild(S3D.canvas)
const verlet=new Verlet()
S3D.add(verlet)
function update(){if(verlet.started&&verlet.objectShowed){S3D.delta=S3D.clock.getDelta()
S3D.time=S3D.clock.getElapsedTime()
verlet.preRender()
S3D.post.render()}
requestAnimationFrame(update)}
requestAnimationFrame(update)})